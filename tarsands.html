><!DOCTYPE HTML>
<html lang="en">

	<head>
			<!-- <link href='https://fonts.googleapis.com/css?family=Ruda:400,700|Cantarell:400,700,400italic,700italic' rel='stylesheet' type='text/css'> -->
			<!-- <link href='https://fonts.googleapis.com/css?family=Bitter' rel='stylesheet' type='text/css'> -->
			<link href="https://fonts.googleapis.com/css?family=Roboto+Slab" rel="stylesheet">
			<meta charset="utf-8">
			<meta name="viewport" content="width=device-width, initial-scale=1"/>
			<meta name="keywords" content="maps,cartography, hazardous waste trade"/>
			<title>Treating tar sands byproducts in the US</title>

			<!--put Bootstrap stylesheet links above style.css-->
			<link rel="stylesheet" href="CSS/bootstrap.min.css">
			<link rel="stylesheet" href="CSS/bootstrap-theme.min.css">
			<link rel="stylesheet" href="CSS/style.css">
			<script type="text/javascript" src="lib/jquery-1.11.3.min.js"></script>
			<script type="text/javascript" src="lib/bootstrap.min.js"></script>
			<script type="text/javascript" src="lib/d3.js" charset="utf-8"></script>
			<script type="text/javascript" src="lib/queue.js"></script>
			<script type="text/javascript" src="lib/topojson.v1.min.js"></script>
			<script type="text/javascript" src="lib/tip.js"></script>
			<script src='lib/nprogress.js'></script>
			<script src='lib/sankey.js'></script>
			<link rel='stylesheet' href='CSS/nprogress.css'/>
			<script src="lib/w3HTMLinclude.js"></script>

	</head>
	<style>
	.node rect {
  cursor: move;
  fill-opacity: .9;
  shape-rendering: crispEdges;
}

.node text {
  pointer-events: none;
  text-shadow: 0 1px 0 #fff;
}

.link {
  fill: none;
  stroke: #000;
  stroke-opacity: .2;
}

.link:hover {
  stroke-opacity: .5;
}
.axis path {
  fill: none;
  stroke: none;
  shape-rendering: crispEdges;
}
.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 8px;
}
</style>
	<body>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-87476640-1', 'auto');
  ga('send', 'pageview');

</script>
	<div w3-include-html="nav.html"></div>
	<script>
	w3IncludeHTML();
	</script>
	<div class="center">
		<div class="jumbotron">
				<div class="container">
						<h1>Treating tar sands byproducts in the US</h1>
				</div>
		</div>
	</div>

		<div class="container map">
			<div class="col-md-8"></div>
			<div class="col-md-4"></div>
		</div>
		<div class="container">
			<div class="col-md-12" id = "bodyText"><h4>Tracking the Flows of Tar Sands Byproducts</h4>
				<div class="text">
				<h5>Oil refined from the Athabasca tar sands of Alberta, Canada is at the center of some of the most highly visible political contests today. The Keystone XL pipeline would have provided a short cut for tar sands crude oil on its way to tanks and refineries in Oklahoma and the Gulf of Mexico. It turns out that refineries that process tar sands oil in Alberta and Saskatchewan ship byproducts to the US for treatment. What is this waste, where exactly is it coming from and going to, and how is it shipped to the US?
				</h5>
				</div>

			<br><br>
			</div>
			<div class="col-md-12 Alberta"></div>
			<div class="col-md-12"><h4>Where are these refineries?</h4></div>
				<div class="text">
				<h5>These are different kinds of processors. Some of them process raw, mined bitumen (e.g. Shell) while others, like Dow, are making material much down the food chain, using already processed oil. 
				</h5>
				</div>

			<br><br>
			
			<div class="col-md-12 Ports"></div>
			<div class="col-md-12"><h4>How does this waste come into the US?</h4></div>
				<div class="text">
				<h5>Through just a few ports. Some receive more shipments than others. Anecdotal evidence (a brief scan of the manifests) suggests much of it is by rail. Visualization based on: https://bost.ocks.org/mike/sankey/
				</h5>
				</div>

			<br><br>

			<div class="col-md-12 Waste"></div>
			<div class="col-md-12"><h4>What is this waste?</h4></div>
				<div class="text">
				<h5>A breakdown of what kind of waste is imported from the oil sands. Unfortunately, as you can see, the ways most waste is classified doesn't tell us much. But we'll break this down more soon...
				</h5>
				</div>

			<br><br>

			<div class="col-md-12 Time"></div>
			<div class="col-md-12"><h4>Has the trade picked up over time?</h4></div>
				<div class="text">
				<h5>So far, our data captures the time period from 2007, 2009-2012.
				</h5>
				</div>

			<br><br>

			</div>
		</div>
	<script>
						//global variables
						var svg, zoomer, path, projection, width100, height100, globalMin, globalMax, arcGroup, exGlobalMin, exGlobalMax, siteKey
						var defaultColor = "#D1D3D4", exDefaultColor = "#4D4D4F"
						var defaultStroke = {"stroke": "#262626", "opacity": 1}
						var u, b, imp, exp;
						var borders, land
						  var tooltip = d3.tip()
						  .attr('class', 'd3-tip')
						  .offset([-5, 0])
						  .html(function(d) {
						    return "<span style='color:white'>" + siteKey[d.id] + "</span>";
						  })

						var flanneryScale;
						var format = d3.format(",.0f")  ;
						//scale stuff
						var smallCircle = window.innerWidth < 500 ? 4 : 8
						var bigCircle = window.innerWidth < 500 ? 16 : 32
						var mapScalar = window.innerWidth < 500 ? .9 : 1.4
					
						//begin script when window loads
						initialize();

						//the first function called once the html is loaded
						function initialize(){

						  height100 =  window.innerHeight/1.5
						  $(".col-md-8").height(height100)
						  width100 = $(".col-md-8").width()

						  svg = d3.select(".col-md-8").append("svg")
						   .attr("id", "mapSVG")
						   .style({"height": height100, "width": width100, "position": "absolute"})

						  //create map projection
						  projection = d3.geo.albers()
						  .center([-10,40])
						  .scale(height100*mapScalar)
						  .translate([(width100/2.25), (height100/2)]);


						  path = d3.geo.path()
						    .projection(projection);

						  u = svg.append("g")
						  b = svg.append("g")



						d3.json("data/na.json", function(error, json) {
						  	
							d3.json("data/borders.json", function(error, json2) {
						  	console.log(json, json2)
							 b.selectAll('path')
						        .data(topojson.feature(json2, json2.objects.borders).features)
						        .enter().append("path")
						          .attr("d", path)
						          .attr("class", "borders")


						      u.selectAll("path")
						        .data(topojson.feature(json, json.objects.na).features)
						        .enter().append("path")
						          .attr("d", path)
						          .attr("class", function (d){
						            return d.properties.gu_a3
						          })
						          .attr("id", function (d){
						            return d.properties.postal
						          })

						      setData(json, json2)
							});
						});

						  
						     
						}

						function setData(json, json2){
							NProgress.start();
						  svg.call(tooltip)
						 
						  land = json
							borders = json2
							 console.log(land, borders)
						  d3.csv("data/tarsands.csv", function(data) {
						    data.forEach(function(d){
						      d.totalQuantityinShipment = +d.totalQuantityinShipment // convert the quantity of waste from string to number
						      d.exporterLAT = +d.exporterLAT
						      d.exporterLONG = +d.exporterLONG
						      d.receivingLat = +d.latitude
						      d.receivingLong = +d.longitude
						      d.receivingFacilityZipCode = +d.receivingfacilityzipcode
						    });

						    var totalShipments = data.length

						    var CHShipments = [data.length, (data.length/totalShipments)*100]

						    var latlongs = d3.nest() //rollup unique exportlatlongs
						    .key(function(d) {return d.exporterLONG;})
						    .entries(data);

						    var latlongsR = d3.nest() //rollup unique receivinglatlongs
						    .key(function(d) {return d.receivingLong;})
						    .entries(data);

						    var nest = d3.nest()
						    .key(function(d) {return d.receivingLong;})
						    .key(function(d) {return d.exporterLONG;})
						    .map(data);



						    siteKey={}
							data.forEach(function(d) {
							    siteKey[d.ReceivingFacilityEPAIDNumber] = d.importer_name+" - "+d.importer_city+", "+d.importer_state;
							    siteKey[d.exporter_key] = d.exporter_name+" - "+d.exporter_city+", "+d.exporter_state;
							});


						    latlongRdump=[];
						    //get facility data ready to project
						     for (var i=0; i<latlongsR.length; i++) {
						              latlongRdump.push({"zip": latlongsR[i]["values"][0]["receivingFacilityZipCode"], "long": latlongsR[i]["values"][0]["longitude"], "lat": latlongsR[i]["values"][0]["latitude"], "id": latlongsR[i]["values"][0]["ReceivingFacilityEPAIDNumber"], "name": latlongsR[i]["values"][0]["importer_name"], "address": latlongsR[i]["values"][0]["importer_address"], "city": latlongsR[i]["values"][0]["importer_city"], "state": latlongsR[i]["values"][0]["importer_state"], "shipments": latlongsR[i]["values"].length, "years": [], "rank": [], "types": [], "units": latlongsR[i]["values"][0]["units_final"]})
						      };

						  var max = d3.max(latlongRdump, function(d) {return d.shipments}),
						  min = d3.min(latlongRdump, function(d) {return d.shipments})
						  latlongRdump.sort(function(a,b){return b.shipments-a.shipments})
						  globalMax = max, globalMin = min

						  var flanMax = calcFlanneryRadius(max);
						  flanneryScale = d3.scale.linear().domain([0, flanMax]).range([smallCircle, bigCircle]);




						    latlongExDump=[];
						      //get facility data ready to project
						     for (var i=0; i<latlongs.length; i++) {
						              latlongExDump.push({"long": latlongs[i]["values"][0]["exporterLONG"], "lat": latlongs[i]["values"][0]["exporterLAT"], "name": latlongs[i]["values"][0]["exporter_name"], "id": latlongs[i]["values"][0]["exporter_key"], "address": latlongs[i]["values"][0]["exporter_address"], "city": latlongs[i]["values"][0]["exporter_city"], "state": latlongs[i]["values"][0]["exporter_state"],"units": latlongs[i]["values"][0]["units_final"], "shipments":latlongs[i]["values"].length, "types": [], "rank": []})
						      };

						      console.log(latlongExDump)

						  var max = d3.max(latlongExDump, function(d) {return d.shipments}),
						  min = d3.min(latlongExDump, function(d) {return d.shipments})
						  latlongExDump.sort(function(a,b){return b.shipments-a.shipments})

						  exGlobalMax = max
						  exGlobalMin = min

						  var flanMax = calcFlanneryRadius(max);
						  flanneryScale = d3.scale.linear().domain([0, flanMax]).range([smallCircle, bigCircle]);


						    exp = svg.append("g")
						    exp.selectAll("circle")
						      .data(latlongExDump)
						      .enter().append("circle").attr("class", "circle")
						      //.attr("class", function(d) {return d.id+" "+d.state+d.years+" "+d.name})
						      .attr("id", function(d){return d.id})
						      .style("fill", exDefaultColor)
						      .style(defaultStroke)
						      .attr("cx", function(d) {return projection([d.long, d.lat])[0]; })
						      .attr("cy", function(d) { return projection([d.long, d.lat])[1]; })
						      .on("mouseover", function(d){
						        tooltip.show(d);
						      })
						      .on("mouseout", function(d){
						        tooltip.hide(d);
						      })
						    exp.selectAll("circle")
						      .transition()
						      .duration(1000)
						      .attr("r", function(d){return radiusFlannery(d.shipments)})

						      imp = svg.append("g")
						    imp.selectAll("circle")
						      .data(latlongRdump)
						      .enter().append("circle").attr("class", "circle circleOnMap")
						      //.attr("class", function(d) {return d.id+" "+d.state+d.years+" "+d.name})
						      .attr("id", function(d){return d.id})
						      .style("fill", defaultColor)
						      .style(defaultStroke)
						      .attr("cx", function(d) {return projection([d.long, d.lat])[0]; })
						      .attr("cy", function(d) { return projection([d.long, d.lat])[1]; })
						      .on("mouseover", function(d){
						        tooltip.show(d);
						        highlight(d);
						      })
						      .on("mouseout", function(d){
						        tooltip.hide(d);
						        dehighlight(d);
						      })
						      .on("click", function(d){
						      	d3.selectAll(".arc").remove();
						        exportThis(d, latlongs, nest)
						      })
						    imp.selectAll("circle")
						      .transition()
						      .duration(1000)
						      .attr("r", function(d){return radiusFlannery(d.shipments)})




						  var flanMax = calcFlanneryRadius(globalMax);
						  flanneryScale = d3.scale.linear().domain([0, flanMax]).range([smallCircle, bigCircle]);

						  var stringwork2 = ["Importers","Exporters"]
						  var circleData = [[globalMax, defaultColor], [globalMin, defaultColor], [exGlobalMax, exDefaultColor], [exGlobalMin, exDefaultColor]]
						  //var circleSpot = [34, 53, 58, 34, 54, 57]

						  var legendKey = ["Max Imports", "Min Imports","Max Exports", "Min Exports"]

							width100 = $(".col-md-4").width()
							//height100=$(".map").height()
							var scalar = window.innerWidth < 500 ? 3 : 2 //scale based on screen size
							$(".col-md-4").height(height100/scalar)
							d3.select(".col-md-4").append("div")
								.attr("class", "legDiv")
								.style({"width": width100, "height": (height100/scalar)+"px", "position": "absolute"})
							var leg = d3.selectAll(".legDiv").append("svg")
								.attr("id", "legSVG")
								.style({"width": width100, "height": (height100/scalar)+"px","position": "absolute"})

							 leg.selectAll("circle")
						      .data(circleData)
						      .enter()
						      .append("circle")
						      .style(defaultStroke)
						      //.attr("class", function(d) {return data.parent.name})
						      .style("fill", function(d){return d[1]})
						      .attr("r", function(d){return radiusFlannery(d[0])})
						      .attr("cy", function(d,i){
						      	//y position should be function of largest radius
						      	var def = window.innerWidth < 500 ? 35 : 60 //scale based on screen size
						      	var max = i > 1? exGlobalMax : globalMax
						      	var otherCirclesPosition = def + radiusFlannery(max) - radiusFlannery(d[0])
						      	var position = i == 0 ? def : otherCirclesPosition
						      	position = i > 1 ? position+2*radiusFlannery(max)+radiusFlannery(exGlobalMax) : position
						      	return position
						      })
						      .attr("cx", radiusFlannery(globalMax)+20)

						      function yScalar (d,i){
							 	var def = window.innerWidth < 500 ? 35 : 60 //scale based on screen size
							 	var max = i > 1 ? exGlobalMax : globalMax
						      	var otherCirclesPosition = def + radiusFlannery(max) - radiusFlannery(d[0])*2
						      	otherCirclesPosition = i > 1 ? otherCirclesPosition+2*radiusFlannery(max)+radiusFlannery(exGlobalMax) : otherCirclesPosition
						      	return otherCirclesPosition
							  }

						     leg.selectAll("circletitle")
						      .data(["Number of shipments"])
						       .enter()
						       .append("text")
						       .text(function(d){return d})
						       .attr("text-anchor", "right")
						       .attr("x", 16)
						       .attr("y", 10) // + height100/1.5
						       .attr("class", "legendTitle")


						     leg.selectAll("circletext")
						      .data(circleData)
						       .enter()
						       .append("text")
						       .text(function(d, i){return legendKey[i]+": "+format(d[0])+" shipments"})
						       .attr("text-anchor", "right")
						       .attr("x", radiusFlannery(globalMax)*2+20)
						       .attr("y",function(d,i){
						       	return yScalar(d,i)
						       })
						       .attr("class", "legendText")


						     leg.selectAll("circlelines")
						     	.data(circleData)
						     	.enter()
						     	.append("line")          // attach a line
							    .style("stroke", "black")  // colour the line
							    .attr("x1", radiusFlannery(globalMax)+20)     // x position of the first end of the line
							    .attr("y1",  function(d,i){
							      	//y position should be function of largest radius
							      	return yScalar(d,i)
						      	})    // y position of the first end of the line
							    .attr("x2", radiusFlannery(globalMax)*2+20)     // x position of the second end of the line
							    .attr("y2", function(d,i){
							      	return yScalar(d,i)
						      	}) //y position of the second end of the line




						  leg.selectAll("flowline")
						    .data([globalMin, globalMax])
						    .enter()
						    .append("rect")
						    //.attr("class", function(d) {return data.parent.name})
						    .style("fill", function(d){return "#252525"})
						    .attr("width", 100)
						    .attr("height", function(d,i){if(i==0){return 2}else{return 15}})
						    .attr("y", function(d,i){if(i==0){return radiusFlannery(globalMax)*6} else{return radiusFlannery(globalMax)*6+20}})
						    .attr("x", 16)

						  leg.selectAll("texts")
						    .data([globalMin, globalMax])
						    .enter()
						    .append('text')
						    .attr("x", 16)
						    .attr("y", function(d,i){if(i==0){return radiusFlannery(globalMax)*6 -4} else{return radiusFlannery(globalMax)*6 +16}})
						    .text(function(d, i){if(i==0){return "Minimum # of shipments: "+ globalMin}else{return "Maximum: "+globalMax}})
						    .attr("class", "legendText")
						  
						  arcGroup = svg.append('g');
						
						//Alberta map here
						$(".Alberta").height(height100)
						width100 = $(".Alberta").width()

						svgAlberta = d3.select(".Alberta").append("svg")
						   .style({"height": height100, "width": width100/2})

						  //create map projection
						  projectionA = d3.geo.albers()
						  .center([-24,52])
						  .scale(height100*mapScalar*5)
						  .translate([0, (height100/2)]);


						  pathA = d3.geo.path()
						    .projection(projectionA);

						  au = svgAlberta.append("g")
						  ab = svgAlberta.append("g")

						      ab.selectAll('path')
						        .data(topojson.feature(borders, borders.objects.borders).features)
						        .enter().append("path")
						          .attr("d", pathA)
						          .attr("class", "borders")


						      au.selectAll("path")
						        .data(topojson.feature(land, land.objects.na).features)
						        .enter().append("path")
						          .attr("d", pathA)
						          .attr("class", function (d){
						            return d.properties.gu_a3
						          })
						          .attr("id", function (d){
						            return d.properties.postal
						          })
						    
						

		

						    expA = svgAlberta.append("g")
						    expA.selectAll("circle")
						      .data(latlongExDump)
						      .enter().append("circle").attr("class", "circle")
						      //.attr("class", function(d) {return d.id+" "+d.state+d.years+" "+d.name})
						      .attr("id", function(d){return d.id})
						      .style("fill", exDefaultColor)
						      .style(defaultStroke)
						      .attr("cx", function(d) {return projectionA([d.long, d.lat])[0]; })
						      .attr("cy", function(d) { return projectionA([d.long, d.lat])[1]; })
						      .on("mouseover", function(d){
						        tooltip.show(d);
						      })
						      .on("mouseout", function(d){
						        tooltip.hide(d);
						      })
						      .attr("r", function(d){return radiusFlannery(d.shipments)})




						  //ports map
						  //Alberta map here
						$(".Ports").height(height100)
						width100 = $(".Ports").width()

						svgPorts = d3.select(".Ports").append("svg")
						   .style({"height": height100, "width": width100})

						var stuff = {"nodes": [], "links":[]}
						var exPORT = d3.nest() //rollup unique exportlatlongs
						.key(function(d) {return d.exporter_key})
						.key(function(d) {return d.portCity+", "+d.portState})
						.rollup(function(leaves) { return leaves.length }) // 
						.map(data);

						var imPORT = d3.nest() //rollup unique exportlatlongs
						.key(function(d) {return d.portCity+", "+d.portState})
						.key(function(d) {return d.ReceivingFacilityEPAIDNumber})
						.rollup(function(leaves) { return leaves.length }) // 
						.map(data);

						var portNest = d3.nest() //rollup unique exportlatlongs
						.key(function(d) {return d.ReceivingFacilityEPAIDNumber})
						.map(data);

						var exportnames = d3.keys(exPORT)
						var importnames = d3.keys(portNest)
						var portz = d3.keys(imPORT)
						exportnames.forEach(function(d){
							stuff.nodes.push({"name": d})
						})
						importnames.forEach(function(d){
							stuff.nodes.push({"name": d})
						})
						portz=portz.filter(function(d){return d.length > 3})
						portz.forEach(function(d){
							stuff.nodes.push({"name": d})
						})

						var dump = stuff.nodes
						for (x=0; x<dump.length; x++){
							s = dump[x].name
							//find all partners
							if (exPORT[s]){
								//if exporter...
								var temp = d3.keys(exPORT[s])
								for (l=0; l<temp.length; l++){
									t = temp[l]
									for (n=0; n<dump.length;n++){
										if (t == dump[n].name){var ret = n}
									}
									t=ret
									v = d3.values(exPORT[s])[l]
									stuff.links.push({"source":x,"target":t,"value":v})
								}
							} else if (imPORT[s]){
								var temp = d3.keys(imPORT[s])
								for (l=0; l<temp.length; l++){
									t = temp[l]
									for (n=0; n<dump.length;n++){
										if (t == dump[n].name){var ret = n}
									}
									t=ret
									v = d3.values(imPORT[s])[l]
									stuff.links.push({"source":x,"target":t,"value":v})
								}
							}
						}
						console.log(siteKey)
						var sankey = d3.sankey()
						    .size([width100, height100])
						    .nodeWidth(15)
						    .nodePadding(10)
						    .nodes(stuff.nodes)
						    .links(stuff.links)
						    .layout(20)
						var pathP = sankey.link();
						var formatNumber = d3.format(",.0f")
					    var color = d3.scale.category20();


						 var link = svgPorts.append("g").selectAll(".link")
					      .data(stuff.links)
					    .enter().append("path")
					      .attr("class", "link")
					      .attr("d", pathP)
					      .style("stroke-width", function(d) { return Math.max(1, d.dy); })
					      .sort(function(a, b) { return b.dy - a.dy; });

					  link.append("title")
					      .text(function(d) { return d.source.name + " â†’ " + d.target.name + "\n" + formatNumber(d.value); });

					  var node = svgPorts.append("g").selectAll(".node")
					      .data(stuff.nodes)
					    .enter().append("g")
					      .attr("class", "node")
					      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })

					  node.append("rect")
					      .attr("height", function(d) { return d.dy; })
					      .attr("width", sankey.nodeWidth())
					      .style("fill", function(d) { return d.color = color(d.name.replace(/ .*/, "")); })
					      .style("stroke", function(d) { return d3.rgb(d.color).darker(2); })
					    .append("title")
					      .text(function(d) { return d.name + "\n" + formatNumber(d.value); });

					  node.append("text")
					      .attr("x", -6)
					      .attr("y", function(d) { return d.dy / 2; })
					      .attr("dy", ".35em")
					      .attr("text-anchor", "end")
					      .attr("transform", null)
					      .text(function(d) { var ret = siteKey[d.name] ? siteKey[d.name] : d.name ; return ret; })
					      .style("font-size", "10px")
					    .filter(function(d) { return d.x < width100 / 2; })
					      .attr("x", 6 + sankey.nodeWidth())
					      .attr("text-anchor", "start");
/*
					 d3.csv("data/ports.csv", function(portdata) {
    						  portdata.forEach(function (d){d.lat = +d.latitude, d.long = +d.longitude})
    						
    						  portdata = portdata.filter(function(d){return portz.includes(d.name)})

							  var portNest = d3.nest() //rollup unique exportlatlongs
							    .key(function(d) {return d.portCity+", "+d.portState})
							    .map(data);

    						  var portzLength = []
							  portz.forEach(function(d){
							  	portzLength[d] = portNest[d].length
							  })
							  var portMax = d3.max(d3.values(portzLength))

							  var portMin = d3.min(d3.values(portzLength))
							    portMax = calcFlanneryRadius(portMax);
							    portMin = calcFlanneryRadius(portMin);
							    console.log(smallCircle, bigCircle)
	  							flanneryScale = d3.scale.linear().domain([portMin, portMax]).range([smallCircle, bigCircle]);
	  						  ports = svg.append("g")
							  ports.selectAll("circle")
							    .data(portdata)
							    .enter().append("circle")
							    .attr("class", "ports")
							    .style("fill", "red")
							    .style("fill-opacity", ".3")
							    .style(defaultStroke)
							    .attr("r", function(d){return radiusFlannery(portzLength[d.name])})
							    .attr("cx", function(d) {return projection([d.long, d.lat])[0]; }) 
							    .attr("cy", function(d) { return projection([d.long, d.lat])[1]; })
						  })
/**/

				
/*
						///
						  //create map projection
						  projectionP = d3.geo.albers()
						  .center([-16,47])
						  .scale(height100*mapScalar*2)
						  .translate([0, (height100/2)]);


						  pathP = d3.geo.path()
						    .projection(projectionP);

						  pu = svgPorts.append("g")
						  pb = svgPorts.append("g")
						      pb.selectAll('path')
						        .data(topojson.feature(borders, borders.objects.borders).features)
						        .enter().append("path")
						          .attr("d", pathP)
						          .attr("class", "borders")


						      pu.selectAll("path")
						        .data(topojson.feature(land, land.objects.na).features)
						        .enter().append("path")
						          .attr("d", pathP)
						          .attr("class", function (d){
						            return d.properties.gu_a3
						          })
						          .attr("id", function (d){
						            return d.properties.postal
						          })
						    
						  ports = svgPorts.append("g")
						  
						  var portNest = d3.nest() //rollup unique exportlatlongs
						    .key(function(d) {return d.portCity+", "+d.portState})
						    .map(data);


						  var portz = d3.keys(portNest)
						  portz=portz.filter(function(d){return d.length > 3})
						  var portzLength = []
						  portz.forEach(function(d){
						  	portzLength[d] = portNest[d].length
						  })

						  svgPorts.call(tooltip)
						  d3.csv("data/ports.csv", function(portdata) {
    						  portdata.forEach(function (d){d.lat = +d.latitude, d.long = +d.longitude})
    						
    						  portdata = portdata.filter(function(d){return portz.includes(d.name)})

							  var portMax = d3.max(d3.values(portzLength))

							  var portMin = d3.min(d3.values(portzLength))
							    portMax = calcFlanneryRadius(portMax);
							    portMin = calcFlanneryRadius(portMin);
	  							flanneryScale = d3.scale.linear().domain([portMin, portMax]).range([smallCircle, bigCircle]);

							  ports.selectAll("circle")
							    .data(portdata)
							    .enter().append("circle")
							    .attr("class", "ports")
							    .style("fill", "red")
							    .style(defaultStroke)
							    .attr("r", function(d){return calcFlanneryRadius(portzLength[d.name])})
							    .attr("cx", function(d) {return projectionP([d.long, d.lat])[0]; }) 
							    .attr("cy", function(d) { return projectionP([d.long, d.lat])[1]; })
						  })*/



						  $(".Time").height(height100+100)
							width100 = $(".Time").width()

							svgT = d3.select(".Time").append("svg")
						   .style({"height": height100+100, "width": width100})

						   var yearnest = d3.nest()
						   	.key(function(d) {return d.Year})
							.rollup(function(leaves) { return leaves.length }) // 
							.map(data);
							console.log(yearnest)
							var mini = d3.min(d3.values(yearnest))
							var maxi = d3.max(d3.values(yearnest))
						   

						  var barPadding = 15;
							barheight=15
						  yearskey = [yearnest["2007"],0,yearnest["2009"],yearnest["2010"],yearnest["2011"],yearnest["2012"]]
						    var years = ["2007", "2008", "2009", "2010", '2011', '2012']

						var y = d3.scale.linear()
						    .domain([maxi, mini])
						    .range([5, height100-15]);

						  var x = d3.scale.linear()
						    .domain([years[0], years[years.length-1]])
						    .range([5, width100-50]);


						  var line = d3.svg.line()
						      .x(function(d, i) {return x(years[i]); })
						      .y(function(d, i) { return y(d); });

						  svgT.append("path")
						      .datum(yearskey)
						      .attr("class", "line")
						      .style("stroke", function(d){
							      var fill = "#D1D3D4" 
							      return fill
						      })
						      .attr("transform", "translate(" + 5+ "," + 0 + ")")
						      .attr("d", line);

						  svgT.selectAll(".dot")
						    .data(yearskey)
						      .enter().append("circle")
						    .attr("class", "dot")
						    .attr("transform", "translate(" + 5+ "," + 0 + ")")
						    .attr("cx", line.x())
						    .attr("cy", line.y())
						    .attr("r", 8)

						   svgT.selectAll("label")
						    .data(yearskey)
						    .enter().append("text")
						    .attr("y", line.y())
						    .attr("x", line.x())
						    .attr("transform", "translate(" + 10+ "," + 15 + ")")
						    .text(function(d,i){if (years.includes("2007") && years.includes("2008") && i == 1) {var text = "No data"}else { var text = format(d)+"shipments"}; return text})
						    .attr("class", "label")
						  var xAxis = d3.svg.axis()
						      .scale(x)
						      .orient("bottom")
						      .tickValues(years)
						      .tickFormat(d3.format(""))
						 svgT.append("g")
						      .attr("class", "x axis")
						      .call(xAxis)
						  .selectAll("text")
						    .attr("y", height100+70)
						    .attr("x", 0)
						    .style("text-anchor", "start");




						  $(".Waste").height(height100)
							width100 = $(".Waste").width()

							Isvg = d3.select(".Waste").append("svg")
						   .style({"height": height100, "width": width100})
						var types = d3.nest()
							.key(function(d) {return d.hazWasteDesc})
							.rollup(function(leaves) { return leaves.length/data.length }) // 
							.map(data);
							console.log(types)
							var typesdump=d3.values(types)

							height = height100
							width = width100
							var color = d3.scale.ordinal()
	 						 .range(['#a6cee3','#1f78b4','#b2df8a','#33a02c','#fb9a99','#e31a1c','#fdbf6f','#ff7f00','#cab2d6','#6a3d9a','#ffff99','#b15928']);
							Isvg.style("height", height)
							var y = d3.scale.linear()
							    .domain([0, 100])
							    .range([0,height]);

							var icesum= data.length
							dataStore = typesdump.sort(function(a,b){return b-a})
							color.domain(typesdump)

							var tip = d3.tip()
							  .attr('class', 'd3-tip')
							  .direction("e")
							  .offset([10, 0])
							  .html(function(d) {
							    return "<span style='color:white'>" + d + "</span>";
							  })

							Isvg.call(tip)

							var position;

							Isvg.selectAll("rects")
							    .data(dataStore)
							  .enter().append("rect")
							    .attr("y", function(d, i) {
							      var place = dataStore[i - 1] ? position + y(dataStore[i-1]*100) : 0
							      position = place
							      return place; //change to fit for company etc.
							    })
							    .attr("x", width/2-75)
							    .attr("height", function(d) { return y(d*100); })
							    .attr("width", 150)
							    .style({"cursor": "pointer", "fill": function(d) {
							      return color(d)}, "stroke": "black", "stroke-width": ".5px", "opacity": 1})
							    .on("mouseover", function(d){
							    	console.log(d)
							    	x = d3.keys(types)
							    	for (p=0; p<x.length; p++){
							    		if (types[x[p]] == d){tip.show(x[p])} 
							    	}
							    	
							    })
							    .on("mouseout", function(d){tip.hide(d)})

					      }); //end



						  NProgress.done()
						};

						function filter() {
						/*   svg.selectAll('circle')
						    .filter(function (d){return d.namer.indexOf("CLEAN HARBOR") == -1}) // >-1
						    .style("fill", "blue")
						    //.remove()
						*/
						}

						function highlight(data){
						  svg.selectAll(".circle")
						    .transition().duration(500)
						    .style({"opacity": ".2"})
						  svg.selectAll("#"+data.id)
						    .transition().duration(500)
						    .style({"opacity": "1"})
						}

						function dehighlight(data){
						  svg.selectAll(".circle")
						    .transition().duration(500)
						    .style({"opacity": "1"})
						};

						function drawLinesOver(data, base){
							console.log(data, base)
						  //var max = d3.max(data, function(d) {return d.total_waste}),
						  //min = d3.min(data, function(d) {return d.total_waste})

						  lineStroke = d3.scale.sqrt()
						    .domain([globalMin, globalMax])
						    .range([2, 15])

						  //based on: http://bl.ocks.org/enoex/6201948

						  var path = d3.geo.path()
						    .projection(projection);

						// --- Helper functions (for tweening the path)
						        var lineTransition = function lineTransition(path) {
						            path.transition()
						                //NOTE: Change this number (in ms) to make lines draw faster or slower
						                .duration(1500)
						                .attrTween("stroke-dasharray", tweenDash)
						                .each("end", function(d,i) {
						                    ////Uncomment following line to re-transition
						                    //d3.select(this).call(transition);

						                    //We might want to do stuff when the line reaches the target,
						                    //  like start the pulsating or add a new point or tell the
						                    //  NSA to listen to this guy's phone calls
						                    //doStuffWhenLineFinishes(d,i);
						                });
						        };
						        var tweenDash = function tweenDash() {
						            //This function is used to animate the dash-array property, which is a
						            //  nice hack that gives us animation along some arbitrary path (in this
						            //  case, makes it look like a line is being drawn from point A to B)
						            var len = this.getTotalLength(),
						                interpolate = d3.interpolateString("0," + len, len + "," + len);

						            return function(t) { return interpolate(t); };
						        };

						var links = [];
						for(var i=0, len=data.length; i<len; i++){
						    // (note: loop until length - 1 since we're getting the next
						    //  item with i+1)
						        links.push({
						            type: "LineString",
						            coordinates: [
						                [ data[i].long, data[i].lat ],
						                [ base.long, base.lat ]
						            ],
						            shipments: data[i].shipments
						        });
						    }
						var pathArcs = arcGroup.selectAll("arc")
						            .data(links);

						        //enter
						        pathArcs.enter()
						            .append("path")
						            .style({
						                fill: 'none',
						            });

						        //update
						        pathArcs.attr({
						                //d is the points attribute for this path, we'll draw
						                //  an arc between the points using the arc function
						                d: path
						            })
						            .style("stroke", "#252525")
						            .attr("class", "arc")
						            .style('stroke-width', function(d) {return lineStroke(d.shipments)})
						                //'stroke-dasharray': '5'
						            .call(lineTransition); //at end of function call positions?
						}
						//various helper functions here: calculating flannery's compensation, and svg z-indexing.
						//flannery compensation for circles. modified from here: http://codepen.io/mxfh/pen/pggXoW
						var calcFlanneryRadius = function(x, max) {
						  // Flannery Compensation formula as described here:
						  //http://www.scribd.com/doc/33408233/SUG243-Cartography-Proportional-Symbol#scribd
						  // log x * 0.57
						  // anti log
						  var flannery = 0.57;
						  var log = Math.log(x);
						  var r = log * flannery;
						  r = Math.exp(r);
						  return (r);
						};

						var radiusFlannery = function(x) {
						  return flanneryScale(calcFlanneryRadius(x));
						};

						function exportThis(data, latlongs, nest){
							console.log(data, latlongs, nest)
						  latlongdump = [];
						  var p = nest[data.long]
						  var keys = d3.keys(p)
						  for (var k=0; k<keys.length; k++){
						    latlongdump.push({"lat": p[keys[k]][0].exporterLAT, "long": p[keys[k]][0].exporterLONG, "shipments":p[keys[k]].length})
						  }
						  //draw lines between exporters and this site
						  drawLinesOver(latlongdump, data);
						}
					</script>

					
	</body>


</html>
